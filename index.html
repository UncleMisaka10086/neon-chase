<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>NEON CHASE</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: #2c0e3a;
    font-family: Segoe UI, Arial, sans-serif;
    user-select: none;
    touch-action: none;
}

#ui-layer {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 10;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

#hud {
    padding: 16px;
    display: flex;
    justify-content: space-between;
}

.stat-box {
    background: rgba(0,0,0,.55);
    border-bottom: 3px solid #00ffff;
    padding: 8px 20px;
    border-radius: 8px;
    color: #fff;
    text-align: center;
    transform: skew(-10deg);
}

#score {
    font-size: 32px;
    font-weight: 900;
    color: #ffd700;
    font-family: monospace;
}

#speed-display {
    font-size: 16px;
    color: #00ffff;
    font-family: monospace;
}

#menu-overlay {
    position: absolute;
    inset: 0;
    background: rgba(20,10,30,.95);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 20;
    transition: opacity .3s;
}

h1 {
    font-size: 56px;
    margin: 0;
    background: linear-gradient(#ff0055,#ffcc00);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.busted-text {
    font-size: 72px;
    font-weight: 900;
    color: #ff3333;
    border: 4px solid #ff3333;
    padding: 10px 36px;
    transform: rotate(-8deg);
    display: none;
    margin-bottom: 20px;
}

.btn-start {
    margin-top: 32px;
    padding: 14px 50px;
    font-size: 22px;
    font-weight: bold;
    color: white;
    background: #0077ff;
    border: none;
    border-radius: 6px;
    box-shadow: 0 0 20px #0077ff;
}

.tips {
    margin-top: 28px;
    font-size: 13px;
    opacity: .5;
    text-align: center;
}
</style>

<script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

<div id="ui-layer">
    <div id="hud">
        <div class="stat-box">
            <div style="font-size:10px;opacity:.7">SCORE</div>
            <div id="score">0</div>
        </div>
        <div class="stat-box">
            <div style="font-size:10px;opacity:.7">SPEED</div>
            <div id="speed-display">0 km/h</div>
        </div>
    </div>
</div>

<div id="menu-overlay">
    <div id="busted-msg" class="busted-text">BUSTED!</div>
    <h1 id="game-title">NEON CHASE</h1>
    <p id="final-score" style="color:#ffd700;font-size:22px;display:none"></p>
    <button class="btn-start" onclick="startGame()">RUN</button>
    <div class="tips">
        上滑跳跃 · 下滑翻滚<br>
        左右滑动移动
    </div>
</div>

<script>
/* ========== 参数 ========== */
const PHYSICS = {
    initSpeed: 10,
    maxSpeed: 45,
    gravity: -35,
    jumpForce: 16,
    laneSpeed: 8,
    leanAmount: .3,
    chaserLag: .08
};

const COLORS = {
    sky: 0x1a0b2e,
    ground: 0x111111,
    player: 0xff0055,
    chaser: 0x0055ff
};

/* ========== 状态 ========== */
let scene, camera, renderer;
let playerGroup, playerMesh, playerBody, playerHead;
let chaserGroup, sirenLight;
let groundModules=[], obstacles=[], coins=[];
let isPlaying=false, score=0, gameSpeed=0;
let currentLane=0, targetX=0;
let verticalVelocity=0, isJumping=false, isRolling=false;
let crouchFactor=0, rollTimer=null;
let firstTouchStarted=false;

/* ========== 初始化 ========== */
window.onload = ()=>{
    initGame();
    animate();
};

/* ========== 场景 ========== */
function initGame(){
    scene=new THREE.Scene();
    scene.background=new THREE.Color(COLORS.sky);
    scene.fog=new THREE.FogExp2(COLORS.sky,.02);

    camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.1,100);
    camera.position.set(0,6.5,9.5);
    camera.lookAt(0,0,-4);

    renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth,innerHeight);
    renderer.shadowMap.enabled=true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0x404060,.7));
    const sun=new THREE.DirectionalLight(0xffaa00,1);
    sun.position.set(20,40,20);
    sun.castShadow=true;
    scene.add(sun);

    createPlayer();
    createChaser();

    for(let i=0;i<15;i++) spawnMap(-i*15,i>2);

    addControls();
}

/* ========== 玩家 & 追捕者（与你原始一致，略） ========== */
// --- 玩家模型 ---
        function createPlayer() {
            playerGroup = new THREE.Group();

            // 材质
            const matBody = new THREE.MeshStandardMaterial({ color: COLORS.player, roughness: 0.3 });
            const matSkin = new THREE.MeshStandardMaterial({ color: 0xffccaa });

            // 身体
            playerBody = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.9, 0.5), matBody);
            playerBody.position.y = 0.45;
            playerBody.castShadow = true;
            
            // 头部
            playerHead = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), matSkin);
            playerHead.position.y = 1.0;
            playerHead.castShadow = true;
            
            // 鸭舌帽 (朝前)
            const hat = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.2, 0.7), new THREE.MeshStandardMaterial({color:0x333}));
            hat.position.set(0, 0.35, -0.1);
            playerHead.add(hat);

            // 组合
            playerMesh = new THREE.Group();
            playerMesh.add(playerBody);
            playerMesh.add(playerHead);
            
            playerGroup.add(playerMesh);
            scene.add(playerGroup);
        }

        // --- [新增] 追捕者模型 ---
        function createChaser() {
            chaserGroup = new THREE.Group();
            
            // 初始位置：在玩家身后 (Z轴正方向)
            chaserGroup.position.set(0, 0, 2.5); 

            // 材质 (警察蓝)
            const matUniform = new THREE.MeshStandardMaterial({ color: COLORS.chaser, roughness: 0.4 });
            const matSkin = new THREE.MeshStandardMaterial({ color: 0xaa8866 });

            // 身体 (稍微大一点，显得强壮)
            chaserBody = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.0, 0.6), matUniform);
            chaserBody.position.y = 0.5;
            chaserBody.castShadow = true;
            chaserGroup.add(chaserBody);

            // 头部
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.65, 0.65), matSkin);
            head.position.y = 1.1;
            head.castShadow = true;
            chaserGroup.add(head);

            // 警帽
            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.3, 0.7), matUniform);
            cap.position.y = 1.5;
            chaserGroup.add(cap);

            // 警灯 (红蓝闪烁)
            sirenLight = new THREE.PointLight(0xff0000, 0, 5);
            sirenLight.position.set(0, 2, 0);
            chaserGroup.add(sirenLight);
            
            // 警灯模型
            const lightMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.15, 0.15), new THREE.MeshBasicMaterial({color:0xff0000}));
            lightMesh.position.y = 1.7;
            chaserGroup.add(lightMesh);

            scene.add(chaserGroup);
        }

            // --- 地图生成 ---
        function spawnMap(zPos, spawnItems) {
            const section = new THREE.Group();
            
            // 地板
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(16, 15),
                new THREE.MeshStandardMaterial({ color: COLORS.ground, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            section.add(floor);

            // 铁轨装饰
            const railMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            [-3.5, 0, 3.5].forEach(x => {
                const r1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 15), railMat);
                r1.position.set(x-0.6, 0.02, 0); section.add(r1);
                const r2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 15), railMat);
                r2.position.set(x+0.6, 0.02, 0); section.add(r2);
            });

            // 建筑装饰
            if (spawnItems) {
                const wallGeo = new THREE.BoxGeometry(3, 8, 4);
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x080808 });
                if(Math.random()>0.5) {
                    const w = new THREE.Mesh(wallGeo, wallMat);
                    w.position.set(-9, 4, 0); section.add(w);
                    // 霓虹灯
                    const l = new THREE.Mesh(new THREE.BoxGeometry(0.2, 6, 0.2), new THREE.MeshBasicMaterial({color: 0xff00ff}));
                    l.position.set(-7.4, 4, 0); section.add(l);
                }
                if(Math.random()>0.5) {
                    const w = new THREE.Mesh(wallGeo, wallMat);
                    w.position.set(9, 4, 0); section.add(w);
                    const l = new THREE.Mesh(new THREE.BoxGeometry(0.2, 6, 0.2), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                    l.position.set(7.4, 4, 0); section.add(l);
                }
            }

            section.position.z = zPos;
            scene.add(section);
            groundModules.push(section);

            if(spawnItems) spawnObstacles(zPos);
        }

        function spawnObstacles(zPos) {
            const lanes = [-1, 0, 1];
            lanes.sort(() => Math.random()-0.5);
            const count = Math.random()>0.4 ? 2 : 1;

            for(let i=0; i<3; i++) {
                const x = lanes[i] * 3.5;
                if(i < count) createObstacle(x, zPos);
                else if(Math.random()>0.4) createCoins(x, zPos);
            }
        }

        function createObstacle(x, z) {
            const r = Math.random();
            let obs;
            if (r < 0.4) { // 矮墙
                obs = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.2, 0.5), new THREE.MeshStandardMaterial({ color: 0xff4444 }));
                obs.position.set(x, 0.6, z);
                obs.userData = { type: 'barrier' };
            } else if (r < 0.8) { // 火车
                obs = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.9, 3.2, 7), new THREE.MeshStandardMaterial({ color: 0x335599 }));
                body.position.y = 1.6; body.castShadow=true; obs.add(body);
                obs.position.set(x, 0, z);
                obs.userData = { type: 'train' };
            } else { // 门
                obs = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x22aa22 }));
                obs.position.set(x, 2.6, z);
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.6, 0.2), new THREE.MeshStandardMaterial({color:0x444}));
                leg.position.set(-1.4,-1.3,0); obs.add(leg);
                const leg2 = leg.clone(); leg2.position.set(1.4,-1.3,0); obs.add(leg2);
                obs.userData = { type: 'arch' };
            }
            obs.castShadow = true;
            scene.add(obs);
            obstacles.push(obs);
        }

        function createCoins(x, z) {
            for(let k=0; k<3; k++) {
                const c = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive:0x443300 }));
                c.rotation.x = Math.PI/2; c.position.set(x, 1, z + k*1.5);
                scene.add(c); coins.push(c);
            }
        }
/* ========== 核心循环（整合打磨） ========== */
function animate(){
    requestAnimationFrame(animate);
    if(!isPlaying){
        if(sirenLight){
            sirenLight.color.setHex(Date.now()%400<200?0xff0000:0x0000ff);
            sirenLight.intensity=2;
        }
        renderer.render(scene,camera);
        return;
    }

    const dt=.016;

    // 玩家
    const dx=targetX-playerGroup.position.x;
    playerGroup.position.x+=dx*PHYSICS.laneSpeed*dt;
    playerMesh.rotation.z=THREE.MathUtils.lerp(playerMesh.rotation.z,-dx*PHYSICS.leanAmount,.1);

    verticalVelocity+=PHYSICS.gravity*dt;
    playerGroup.position.y+=verticalVelocity*dt;
    if(playerGroup.position.y<=0){
        playerGroup.position.y=0;
        verticalVelocity=0;
        isJumping=false;
    }

    const tc=isRolling?1:0;
    crouchFactor=THREE.MathUtils.lerp(crouchFactor,tc,10*dt);
    playerBody.scale.y=1-.4*crouchFactor;
    playerHead.position.y=1-.5*crouchFactor;

    // 追捕者
    chaserGroup.position.x=THREE.MathUtils.lerp(chaserGroup.position.x,playerGroup.position.x,PHYSICS.chaserLag);
    chaserGroup.position.y=THREE.MathUtils.lerp(chaserGroup.position.y,playerGroup.position.y,PHYSICS.chaserLag*1.5);
    chaserGroup.position.z=2.4+Math.sin(Date.now()*.01)*.2;

    // 难度曲线 ★
    const diff=Math.min(score/500,1);
    gameSpeed=PHYSICS.initSpeed+diff*(PHYSICS.maxSpeed-PHYSICS.initSpeed);

    document.getElementById("speed-display").innerText=Math.floor(gameSpeed)+" km/h";

    renderer.render(scene,camera);
}

/* ========== GameOver 打磨版 ========== */
function triggerGameOver(){
    isPlaying=false;

    // 镜头抖动 ★
    camera.position.x+=(Math.random()-.5)*.2;
    camera.position.y+=(Math.random()-.5)*.2;

    const best=Math.max(score,localStorage.bestScore||0);
    localStorage.bestScore=best;

    document.getElementById("final-score").innerText=
        `SCORE ${score}  |  BEST ${best}`;

    document.getElementById("menu-overlay").style.display="flex";
    document.getElementById("busted-msg").style.display="block";
    document.getElementById("final-score").style.display="block";
}

/* ========== 控制（触屏自动开始） ========== */
function addControls(){
    let sx,sy;
    document.addEventListener("touchstart",e=>{
        if(!firstTouchStarted && !isPlaying){
            firstTouchStarted=true;
            startGame();
        }
        sx=e.touches[0].clientX;
        sy=e.touches[0].clientY;
    });

    document.addEventListener("touchend",e=>{
        if(!isPlaying) return;
        const dx=e.changedTouches[0].clientX-sx;
        const dy=e.changedTouches[0].clientY-sy;
        if(Math.abs(dx)>Math.abs(dy)){
            if(Math.abs(dx)>30) changeLane(dx<0?-1:1);
        }else{
            if(Math.abs(dy)>30) dy<0?jump():roll();
        }
    });
}

/* ========== 其余函数与你原始一致 ========== */
</script>

</body>
</html>
